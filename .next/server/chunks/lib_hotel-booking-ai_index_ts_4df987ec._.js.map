{"version":3,"sources":["../../../lib/hotel-booking-ai/index.ts","../../../lib/hotel-booking-ai/handlers/booking.ts","../../../lib/hotel-booking-ai/handlers/voice.ts","../../../lib/hotel-booking-ai/handlers/monitoring.ts","../../../lib/hotel-booking-ai/handlers/notifications.ts","../../../lib/hotel-booking-ai/handlers/loyalty.ts"],"sourcesContent":["/**\n * Hotel Booking AI - Main Index\n * Central export for all Hotel Booking AI functionality\n */\n\n// Types (explicitly export to avoid conflicts)\nexport type {\n  BookingEngineType,\n  EngineInstance,\n  EngineSessionMetrics,\n  ToolResult,\n  EngineCapability,\n  SkillCategory,\n  BookingSkill,\n  BookingTool,\n  ToolParameter,\n  BookingEngineTemplate,\n  ModelConfig,\n  AgentPersona,\n  EnginePrompts,\n  EngineConfig,\n  ConversationContext,\n  ConversationMessage,\n  BookingIntent,\n  ExtractedBookingData\n} from './types';\n\n// Skills\nexport * from './skills';\n\n// Templates\nexport * from './templates';\n\n// Handlers (importing registers them)\nimport './handlers';\n\n// Re-export convenience functions\nexport {\n  createEngine,\n  getEngine,\n  destroyEngine,\n  listEngines,\n  chat,\n  getGreeting,\n  clearHistory,\n  getAvailableTemplates,\n  getTemplate,\n  getDashboardStats,\n  registerToolHandler,\n  executeTool,\n  getToolsForEngine,\n  getConversationContext\n} from './engine-manager';\n\n// Export types from engine-manager\nexport type { CreateEngineOptions, ChatOptions, ChatResponse } from './engine-manager';\n\nexport {\n  allTemplates,\n  getTemplateById,\n  getTemplateByType,\n  getTemplatesByCapability,\n  hotelBookingAgentTemplate,\n  priceMonitorAgentTemplate,\n  customerSupportAgentTemplate,\n  voiceBookingAgentTemplate,\n  conciergeAgentTemplate,\n  groupBookingAgentTemplate,\n  loyaltyManagerAgentTemplate\n} from './templates';\n\nexport {\n  allSkills,\n  getSkillById,\n  getSkillsByCategory,\n  hotelSearchSkill,\n  destinationSearchSkill,\n  prebookSkill,\n  bookingSkill,\n  cancellationSkill,\n  priceMonitoringSkill,\n  notificationSkill,\n  voiceSkill,\n  customerSupportSkill,\n  loyaltySkill,\n  preferencesSkill\n} from './skills';\n","/**\n * Hotel Booking AI - Booking Handler\n * Handles hotel search, prebook, booking, and cancellation operations\n */\n\nimport type { ConversationContext, ToolResult } from '../types';\nimport { registerToolHandler } from '../engine-manager';\n\n// ========================================\n// MEDICI API INTEGRATION\n// ========================================\n\nconst MEDICI_API_URL = process.env.MEDICI_API_URL || 'https://api.medici.com';\nconst MEDICI_API_KEY = process.env.MEDICI_API_KEY;\n\ninterface MediciApiOptions {\n  endpoint: string;\n  method: 'GET' | 'POST' | 'PUT' | 'DELETE';\n  body?: Record<string, any>;\n  token?: string;\n}\n\nasync function callMediciApi(options: MediciApiOptions): Promise<any> {\n  const { endpoint, method, body, token } = options;\n\n  const headers: HeadersInit = {\n    'Content-Type': 'application/json'\n  };\n\n  if (token) {\n    headers['Authorization'] = `Bearer ${token}`;\n  } else if (MEDICI_API_KEY) {\n    headers['x-api-key'] = MEDICI_API_KEY;\n  }\n\n  try {\n    const response = await fetch(`${MEDICI_API_URL}${endpoint}`, {\n      method,\n      headers,\n      body: body ? JSON.stringify(body) : undefined\n    });\n\n    if (!response.ok) {\n      const errorData = await response.json().catch(() => ({}));\n      throw new Error(errorData.message || `API error: ${response.status}`);\n    }\n\n    return await response.json();\n  } catch (error: any) {\n    console.error('Medici API error:', error);\n    throw error;\n  }\n}\n\n// ========================================\n// HOTEL SEARCH HANDLER\n// ========================================\n\ninterface SearchHotelsParams {\n  destination: string;\n  checkIn: string;\n  checkOut: string;\n  rooms: number;\n  adults: number;\n  children?: number;\n  currency?: string;\n  filters?: {\n    starRating?: number[];\n    priceRange?: { min: number; max: number };\n    amenities?: string[];\n    propertyTypes?: string[];\n  };\n}\n\nasync function handleSearchHotels(\n  params: SearchHotelsParams,\n  context: ConversationContext\n): Promise<ToolResult> {\n  try {\n    const searchParams = {\n      destination: params.destination,\n      checkin: params.checkIn,\n      checkout: params.checkOut,\n      rooms: params.rooms,\n      adults: params.adults,\n      children: params.children || 0,\n      currency: params.currency || 'USD',\n      ...params.filters\n    };\n\n    const result = await callMediciApi({\n      endpoint: '/v1/hotels/search',\n      method: 'POST',\n      body: searchParams\n    });\n\n    // Store search ID in context for later use\n    if (result.searchId) {\n      context.metadata.lastSearchId = result.searchId;\n    }\n\n    return {\n      success: true,\n      data: {\n        searchId: result.searchId,\n        totalResults: result.hotels?.length || 0,\n        hotels: result.hotels?.slice(0, 10).map((hotel: any) => ({\n          hotelId: hotel.hotelId,\n          name: hotel.name,\n          address: hotel.address,\n          starRating: hotel.starRating,\n          rating: hotel.rating,\n          reviewCount: hotel.reviewCount,\n          mainImage: hotel.images?.[0],\n          lowestPrice: hotel.lowestPrice,\n          currency: hotel.currency,\n          amenities: hotel.amenities?.slice(0, 5),\n          distanceFromCenter: hotel.distanceFromCenter\n        }))\n      }\n    };\n  } catch (error: any) {\n    return {\n      success: false,\n      data: null,\n      error: error.message || 'Failed to search hotels'\n    };\n  }\n}\n\nregisterToolHandler('search_hotels', handleSearchHotels as any);\n\n// ========================================\n// DESTINATION SEARCH HANDLER\n// ========================================\n\ninterface SearchDestinationsParams {\n  query: string;\n  limit?: number;\n}\n\nasync function handleSearchDestinations(\n  params: SearchDestinationsParams,\n  context: ConversationContext\n): Promise<ToolResult> {\n  try {\n    const result = await callMediciApi({\n      endpoint: `/v1/destinations/search?q=${encodeURIComponent(params.query)}&limit=${params.limit || 10}`,\n      method: 'GET'\n    });\n\n    return {\n      success: true,\n      data: {\n        destinations: result.destinations?.map((dest: any) => ({\n          id: dest.id,\n          name: dest.name,\n          type: dest.type,\n          country: dest.country,\n          region: dest.region,\n          coordinates: dest.coordinates\n        }))\n      }\n    };\n  } catch (error: any) {\n    return {\n      success: false,\n      data: null,\n      error: error.message || 'Failed to search destinations'\n    };\n  }\n}\n\nregisterToolHandler('search_destinations', handleSearchDestinations as any);\n\n// ========================================\n// PREBOOK HANDLER\n// ========================================\n\ninterface PrebookParams {\n  hotelId: string;\n  roomId: string;\n  rateId: string;\n  checkIn: string;\n  checkOut: string;\n  guests: {\n    adults: number;\n    children?: number;\n    childAges?: number[];\n  };\n}\n\nasync function handlePrebook(\n  params: PrebookParams,\n  context: ConversationContext\n): Promise<ToolResult> {\n  try {\n    const result = await callMediciApi({\n      endpoint: '/v1/booking/prebook',\n      method: 'POST',\n      body: {\n        hotelId: params.hotelId,\n        roomId: params.roomId,\n        rateId: params.rateId,\n        checkin: params.checkIn,\n        checkout: params.checkOut,\n        guests: params.guests\n      }\n    });\n\n    // Store prebook token in context\n    if (result.prebookToken) {\n      context.metadata.prebookToken = result.prebookToken;\n      context.metadata.prebookExpiry = result.expiresAt;\n    }\n\n    return {\n      success: true,\n      data: {\n        prebookToken: result.prebookToken,\n        expiresAt: result.expiresAt,\n        totalPrice: result.totalPrice,\n        currency: result.currency,\n        cancellationPolicy: result.cancellationPolicy,\n        roomDetails: {\n          name: result.room?.name,\n          bedType: result.room?.bedType,\n          maxOccupancy: result.room?.maxOccupancy,\n          amenities: result.room?.amenities\n        },\n        rateDetails: {\n          name: result.rate?.name,\n          mealPlan: result.rate?.mealPlan,\n          refundable: result.rate?.refundable\n        }\n      }\n    };\n  } catch (error: any) {\n    return {\n      success: false,\n      data: null,\n      error: error.message || 'Failed to prebook room'\n    };\n  }\n}\n\nregisterToolHandler('prebook_room', handlePrebook as any);\n\n// ========================================\n// BOOKING HANDLER\n// ========================================\n\ninterface BookingParams {\n  prebookToken: string;\n  guest: {\n    firstName: string;\n    lastName: string;\n    email: string;\n    phone: string;\n    nationality?: string;\n    specialRequests?: string;\n  };\n  payment?: {\n    method: string;\n    cardToken?: string;\n  };\n}\n\nasync function handleBooking(\n  params: BookingParams,\n  context: ConversationContext\n): Promise<ToolResult> {\n  try {\n    // Use stored prebook token if not provided\n    const prebookToken = params.prebookToken || context.metadata.prebookToken;\n\n    if (!prebookToken) {\n      return {\n        success: false,\n        data: null,\n        error: 'No prebook token available. Please prebook a room first.'\n      };\n    }\n\n    const result = await callMediciApi({\n      endpoint: '/v1/booking/book',\n      method: 'POST',\n      body: {\n        prebookToken,\n        guest: params.guest,\n        payment: params.payment\n      }\n    });\n\n    // Store booking info in context\n    context.metadata.lastBookingId = result.bookingId;\n    context.metadata.lastConfirmationNumber = result.confirmationNumber;\n\n    return {\n      success: true,\n      data: {\n        bookingId: result.bookingId,\n        confirmationNumber: result.confirmationNumber,\n        status: result.status,\n        hotelName: result.hotel?.name,\n        checkIn: result.checkIn,\n        checkOut: result.checkOut,\n        roomType: result.room?.name,\n        totalPrice: result.totalPrice,\n        currency: result.currency,\n        guestName: `${params.guest.firstName} ${params.guest.lastName}`,\n        confirmationEmail: params.guest.email\n      }\n    };\n  } catch (error: any) {\n    return {\n      success: false,\n      data: null,\n      error: error.message || 'Failed to complete booking'\n    };\n  }\n}\n\nregisterToolHandler('complete_booking', handleBooking as any);\n\n// ========================================\n// CANCELLATION HANDLER\n// ========================================\n\ninterface CancellationParams {\n  bookingId?: string;\n  confirmationNumber?: string;\n  email?: string;\n  reason?: string;\n}\n\nasync function handleCancellation(\n  params: CancellationParams,\n  context: ConversationContext\n): Promise<ToolResult> {\n  try {\n    // Use stored booking info if not provided\n    const bookingId = params.bookingId || context.metadata.lastBookingId;\n    const confirmationNumber = params.confirmationNumber || context.metadata.lastConfirmationNumber;\n\n    if (!bookingId && !confirmationNumber) {\n      return {\n        success: false,\n        data: null,\n        error: 'Please provide a booking ID or confirmation number.'\n      };\n    }\n\n    const result = await callMediciApi({\n      endpoint: '/v1/booking/cancel',\n      method: 'POST',\n      body: {\n        bookingId,\n        confirmationNumber,\n        email: params.email,\n        reason: params.reason\n      }\n    });\n\n    return {\n      success: true,\n      data: {\n        cancellationId: result.cancellationId,\n        bookingId: result.bookingId,\n        confirmationNumber: result.confirmationNumber,\n        status: result.status,\n        refundAmount: result.refundAmount,\n        refundCurrency: result.refundCurrency,\n        refundStatus: result.refundStatus,\n        cancellationFee: result.cancellationFee,\n        message: result.message || 'Booking successfully cancelled'\n      }\n    };\n  } catch (error: any) {\n    return {\n      success: false,\n      data: null,\n      error: error.message || 'Failed to cancel booking'\n    };\n  }\n}\n\nregisterToolHandler('cancel_booking', handleCancellation);\n\n// ========================================\n// BOOKING LOOKUP HANDLER\n// ========================================\n\ninterface BookingLookupParams {\n  bookingId?: string;\n  confirmationNumber?: string;\n  email?: string;\n}\n\nasync function handleBookingLookup(\n  params: BookingLookupParams,\n  context: ConversationContext\n): Promise<ToolResult> {\n  try {\n    const queryParams = new URLSearchParams();\n    if (params.bookingId) queryParams.set('bookingId', params.bookingId);\n    if (params.confirmationNumber) queryParams.set('confirmationNumber', params.confirmationNumber);\n    if (params.email) queryParams.set('email', params.email);\n\n    const result = await callMediciApi({\n      endpoint: `/v1/booking/lookup?${queryParams.toString()}`,\n      method: 'GET'\n    });\n\n    return {\n      success: true,\n      data: {\n        bookingId: result.bookingId,\n        confirmationNumber: result.confirmationNumber,\n        status: result.status,\n        hotelName: result.hotel?.name,\n        hotelAddress: result.hotel?.address,\n        checkIn: result.checkIn,\n        checkOut: result.checkOut,\n        roomType: result.room?.name,\n        guestName: result.guest?.name,\n        totalPrice: result.totalPrice,\n        currency: result.currency,\n        cancellationPolicy: result.cancellationPolicy,\n        canCancel: result.canCancel,\n        canModify: result.canModify\n      }\n    };\n  } catch (error: any) {\n    return {\n      success: false,\n      data: null,\n      error: error.message || 'Failed to find booking'\n    };\n  }\n}\n\nregisterToolHandler('lookup_booking', handleBookingLookup);\n\n// ========================================\n// HOTEL DETAILS HANDLER\n// ========================================\n\ninterface HotelDetailsParams {\n  hotelId: string;\n}\n\nasync function handleHotelDetails(\n  params: HotelDetailsParams,\n  context: ConversationContext\n): Promise<ToolResult> {\n  try {\n    const result = await callMediciApi({\n      endpoint: `/v1/hotels/${params.hotelId}`,\n      method: 'GET'\n    });\n\n    return {\n      success: true,\n      data: {\n        hotelId: result.hotelId,\n        name: result.name,\n        description: result.description,\n        address: result.address,\n        city: result.city,\n        country: result.country,\n        coordinates: result.coordinates,\n        starRating: result.starRating,\n        rating: result.rating,\n        reviewCount: result.reviewCount,\n        images: result.images,\n        amenities: result.amenities,\n        policies: {\n          checkIn: result.policies?.checkIn,\n          checkOut: result.policies?.checkOut,\n          cancellation: result.policies?.cancellation,\n          children: result.policies?.children,\n          pets: result.policies?.pets\n        },\n        contact: result.contact\n      }\n    };\n  } catch (error: any) {\n    return {\n      success: false,\n      data: null,\n      error: error.message || 'Failed to get hotel details'\n    };\n  }\n}\n\nregisterToolHandler('get_hotel_details', handleHotelDetails as any);\n\nexport {\n  handleSearchHotels,\n  handleSearchDestinations,\n  handlePrebook,\n  handleBooking,\n  handleCancellation,\n  handleBookingLookup,\n  handleHotelDetails\n};\n","/**\n * Hotel Booking AI - Voice Handler\n * Handles voice-based interactions using Azure Communication Services\n */\n\nimport type { ConversationContext, ToolResult } from '../types';\nimport { registerToolHandler } from '../engine-manager';\n\n// ========================================\n// AZURE COMMUNICATION SERVICES CONFIG\n// ========================================\n\nconst AZURE_COMMUNICATION_CONNECTION_STRING = process.env.AZURE_COMMUNICATION_CONNECTION_STRING;\nconst AZURE_SPEECH_KEY = process.env.AZURE_SPEECH_KEY;\nconst AZURE_SPEECH_REGION = process.env.AZURE_SPEECH_REGION || 'eastus';\nconst TWILIO_ACCOUNT_SID = process.env.TWILIO_ACCOUNT_SID;\nconst TWILIO_AUTH_TOKEN = process.env.TWILIO_AUTH_TOKEN;\nconst TWILIO_PHONE_NUMBER = process.env.TWILIO_PHONE_NUMBER;\n\n// ========================================\n// VOICE SESSION MANAGEMENT\n// ========================================\n\ninterface VoiceSession {\n  sessionId: string;\n  callId?: string;\n  phoneNumber: string;\n  status: 'initiating' | 'ringing' | 'connected' | 'ended' | 'failed';\n  startTime: string;\n  endTime?: string;\n  transcript: Array<{\n    speaker: 'agent' | 'customer';\n    text: string;\n    timestamp: string;\n  }>;\n  metadata: Record<string, any>;\n}\n\nconst voiceSessions = new Map<string, VoiceSession>();\n\n// ========================================\n// INITIATE CALL HANDLER\n// ========================================\n\ninterface InitiateCallParams {\n  phoneNumber: string;\n  language?: string;\n  initialMessage?: string;\n  callbackUrl?: string;\n}\n\nasync function handleInitiateCall(\n  params: InitiateCallParams,\n  context: ConversationContext\n): Promise<ToolResult> {\n  try {\n    // Validate phone number format\n    const phoneNumber = params.phoneNumber.replace(/\\D/g, '');\n    if (phoneNumber.length < 10) {\n      return {\n        success: false,\n        data: null,\n        error: 'Invalid phone number format'\n      };\n    }\n\n    const sessionId = `voice-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n\n    // Create voice session\n    const session: VoiceSession = {\n      sessionId,\n      phoneNumber: params.phoneNumber,\n      status: 'initiating',\n      startTime: new Date().toISOString(),\n      transcript: [],\n      metadata: {\n        language: params.language || 'en',\n        initialMessage: params.initialMessage,\n        conversationSessionId: context.sessionId\n      }\n    };\n\n    voiceSessions.set(sessionId, session);\n\n    // In production, this would initiate the actual call via Azure/Twilio\n    // For now, we simulate the response\n    \n    // Simulate call initiation\n    session.status = 'ringing';\n    session.callId = `call-${Date.now()}`;\n\n    // Store session ID in context\n    context.metadata.activeVoiceSession = sessionId;\n\n    return {\n      success: true,\n      data: {\n        sessionId,\n        callId: session.callId,\n        status: session.status,\n        phoneNumber: params.phoneNumber,\n        message: 'Call initiated successfully. Waiting for customer to answer.'\n      }\n    };\n  } catch (error: any) {\n    return {\n      success: false,\n      data: null,\n      error: error.message || 'Failed to initiate call'\n    };\n  }\n}\n\nregisterToolHandler('initiate_call', handleInitiateCall as any);\n\n// ========================================\n// END CALL HANDLER\n// ========================================\n\ninterface EndCallParams {\n  sessionId?: string;\n  reason?: string;\n}\n\nasync function handleEndCall(\n  params: EndCallParams,\n  context: ConversationContext\n): Promise<ToolResult> {\n  try {\n    const sessionId = params.sessionId || context.metadata.activeVoiceSession;\n\n    if (!sessionId) {\n      return {\n        success: false,\n        data: null,\n        error: 'No active voice session found'\n      };\n    }\n\n    const session = voiceSessions.get(sessionId);\n    if (!session) {\n      return {\n        success: false,\n        data: null,\n        error: 'Voice session not found'\n      };\n    }\n\n    // End the session\n    session.status = 'ended';\n    session.endTime = new Date().toISOString();\n\n    // Calculate duration\n    const startTime = new Date(session.startTime).getTime();\n    const endTime = new Date(session.endTime).getTime();\n    const durationSeconds = Math.round((endTime - startTime) / 1000);\n\n    // Clear active session from context\n    delete context.metadata.activeVoiceSession;\n\n    return {\n      success: true,\n      data: {\n        sessionId,\n        status: 'ended',\n        duration: durationSeconds,\n        transcriptLength: session.transcript.length,\n        endReason: params.reason || 'completed',\n        message: 'Call ended successfully'\n      }\n    };\n  } catch (error: any) {\n    return {\n      success: false,\n      data: null,\n      error: error.message || 'Failed to end call'\n    };\n  }\n}\n\nregisterToolHandler('end_call', handleEndCall);\n\n// ========================================\n// TEXT TO SPEECH HANDLER\n// ========================================\n\ninterface SpeakParams {\n  text: string;\n  language?: string;\n  voiceId?: string;\n  rate?: number;\n  pitch?: number;\n}\n\nasync function handleSpeak(\n  params: SpeakParams,\n  context: ConversationContext\n): Promise<ToolResult> {\n  try {\n    const sessionId = context.metadata.activeVoiceSession;\n\n    if (!sessionId) {\n      return {\n        success: false,\n        data: null,\n        error: 'No active voice session'\n      };\n    }\n\n    const session = voiceSessions.get(sessionId);\n    if (!session || session.status !== 'connected') {\n      return {\n        success: false,\n        data: null,\n        error: 'Voice session not connected'\n      };\n    }\n\n    // Add to transcript\n    session.transcript.push({\n      speaker: 'agent',\n      text: params.text,\n      timestamp: new Date().toISOString()\n    });\n\n    // In production, this would use Azure Speech SDK to synthesize speech\n    // For now, we simulate the response\n\n    return {\n      success: true,\n      data: {\n        sessionId,\n        text: params.text,\n        language: params.language || session.metadata.language,\n        voiceId: params.voiceId || 'he-IL-HilaNeural',\n        duration: Math.ceil(params.text.length / 15), // Approximate duration in seconds\n        message: 'Speech synthesized and played'\n      }\n    };\n  } catch (error: any) {\n    return {\n      success: false,\n      data: null,\n      error: error.message || 'Failed to synthesize speech'\n    };\n  }\n}\n\nregisterToolHandler('speak_text', handleSpeak as any);\n\n// ========================================\n// SPEECH TO TEXT HANDLER\n// ========================================\n\ninterface ListenParams {\n  timeout?: number;\n  language?: string;\n  hints?: string[];\n}\n\nasync function handleListen(\n  params: ListenParams,\n  context: ConversationContext\n): Promise<ToolResult> {\n  try {\n    const sessionId = context.metadata.activeVoiceSession;\n\n    if (!sessionId) {\n      return {\n        success: false,\n        data: null,\n        error: 'No active voice session'\n      };\n    }\n\n    const session = voiceSessions.get(sessionId);\n    if (!session || session.status !== 'connected') {\n      return {\n        success: false,\n        data: null,\n        error: 'Voice session not connected'\n      };\n    }\n\n    // In production, this would use Azure Speech SDK for speech recognition\n    // For now, we return a placeholder response\n\n    return {\n      success: true,\n      data: {\n        sessionId,\n        recognized: true,\n        text: '[Customer response would be transcribed here]',\n        confidence: 0.95,\n        language: params.language || session.metadata.language,\n        message: 'Listening for customer input'\n      }\n    };\n  } catch (error: any) {\n    return {\n      success: false,\n      data: null,\n      error: error.message || 'Failed to recognize speech'\n    };\n  }\n}\n\nregisterToolHandler('listen_speech', handleListen);\n\n// ========================================\n// SEND SMS HANDLER\n// ========================================\n\ninterface SendSmsParams {\n  phoneNumber: string;\n  message: string;\n  templateId?: string;\n}\n\nasync function handleSendSms(\n  params: SendSmsParams,\n  context: ConversationContext\n): Promise<ToolResult> {\n  try {\n    // Validate phone number\n    const phoneNumber = params.phoneNumber.replace(/\\D/g, '');\n    if (phoneNumber.length < 10) {\n      return {\n        success: false,\n        data: null,\n        error: 'Invalid phone number format'\n      };\n    }\n\n    // Validate message length\n    if (params.message.length > 1600) {\n      return {\n        success: false,\n        data: null,\n        error: 'Message too long. Maximum 1600 characters.'\n      };\n    }\n\n    // In production, this would use Twilio/Azure to send SMS\n    // For now, we simulate the response\n\n    const messageId = `sms-${Date.now()}-${Math.random().toString(36).substr(2, 6)}`;\n\n    // Store in context for tracking\n    if (!context.metadata.sentMessages) {\n      context.metadata.sentMessages = [];\n    }\n    context.metadata.sentMessages.push({\n      id: messageId,\n      type: 'sms',\n      to: params.phoneNumber,\n      content: params.message,\n      sentAt: new Date().toISOString()\n    });\n\n    return {\n      success: true,\n      data: {\n        messageId,\n        to: params.phoneNumber,\n        status: 'sent',\n        segments: Math.ceil(params.message.length / 160),\n        message: 'SMS sent successfully'\n      }\n    };\n  } catch (error: any) {\n    return {\n      success: false,\n      data: null,\n      error: error.message || 'Failed to send SMS'\n    };\n  }\n}\n\nregisterToolHandler('send_sms', handleSendSms as any);\n\n// ========================================\n// CALL STATUS HANDLER\n// ========================================\n\ninterface CallStatusParams {\n  sessionId?: string;\n}\n\nasync function handleCallStatus(\n  params: CallStatusParams,\n  context: ConversationContext\n): Promise<ToolResult> {\n  try {\n    const sessionId = params.sessionId || context.metadata.activeVoiceSession;\n\n    if (!sessionId) {\n      return {\n        success: false,\n        data: null,\n        error: 'No voice session specified'\n      };\n    }\n\n    const session = voiceSessions.get(sessionId);\n    if (!session) {\n      return {\n        success: false,\n        data: null,\n        error: 'Voice session not found'\n      };\n    }\n\n    const startTime = new Date(session.startTime).getTime();\n    const endTime = session.endTime\n      ? new Date(session.endTime).getTime()\n      : Date.now();\n    const durationSeconds = Math.round((endTime - startTime) / 1000);\n\n    return {\n      success: true,\n      data: {\n        sessionId,\n        callId: session.callId,\n        status: session.status,\n        phoneNumber: session.phoneNumber,\n        duration: durationSeconds,\n        transcriptLength: session.transcript.length,\n        language: session.metadata.language\n      }\n    };\n  } catch (error: any) {\n    return {\n      success: false,\n      data: null,\n      error: error.message || 'Failed to get call status'\n    };\n  }\n}\n\nregisterToolHandler('get_call_status', handleCallStatus);\n\n// ========================================\n// TRANSFER CALL HANDLER\n// ========================================\n\ninterface TransferCallParams {\n  sessionId?: string;\n  targetNumber: string;\n  reason?: string;\n}\n\nasync function handleTransferCall(\n  params: TransferCallParams,\n  context: ConversationContext\n): Promise<ToolResult> {\n  try {\n    const sessionId = params.sessionId || context.metadata.activeVoiceSession;\n\n    if (!sessionId) {\n      return {\n        success: false,\n        data: null,\n        error: 'No voice session to transfer'\n      };\n    }\n\n    const session = voiceSessions.get(sessionId);\n    if (!session || session.status !== 'connected') {\n      return {\n        success: false,\n        data: null,\n        error: 'Voice session not connected'\n      };\n    }\n\n    // In production, this would transfer the call\n    // For now, we simulate the response\n\n    return {\n      success: true,\n      data: {\n        sessionId,\n        status: 'transferring',\n        targetNumber: params.targetNumber,\n        reason: params.reason || 'Customer request',\n        message: 'Call transfer initiated'\n      }\n    };\n  } catch (error: any) {\n    return {\n      success: false,\n      data: null,\n      error: error.message || 'Failed to transfer call'\n    };\n  }\n}\n\nregisterToolHandler('transfer_call', handleTransferCall as any);\n\n// ========================================\n// VOICE SESSION UTILITIES\n// ========================================\n\nexport function getVoiceSession(sessionId: string): VoiceSession | undefined {\n  return voiceSessions.get(sessionId);\n}\n\nexport function getActiveVoiceSessions(): VoiceSession[] {\n  return Array.from(voiceSessions.values()).filter(\n    session => session.status === 'connected' || session.status === 'ringing'\n  );\n}\n\nexport function getVoiceSessionTranscript(sessionId: string): VoiceSession['transcript'] | null {\n  const session = voiceSessions.get(sessionId);\n  return session ? session.transcript : null;\n}\n\nexport {\n  handleInitiateCall,\n  handleEndCall,\n  handleSpeak,\n  handleListen,\n  handleSendSms,\n  handleCallStatus,\n  handleTransferCall\n};\n","/**\n * Hotel Booking AI - Price Monitoring Handler\n * Handles price tracking, alerts, and trend analysis\n */\n\nimport type { ConversationContext, ToolResult } from '../types';\nimport { registerToolHandler } from '../engine-manager';\n\n// ========================================\n// PRICE TRACKING DATA STRUCTURES\n// ========================================\n\ninterface PriceAlert {\n  id: string;\n  hotelId: string;\n  hotelName: string;\n  roomType: string;\n  checkIn: string;\n  checkOut: string;\n  targetPrice?: number;\n  alertType: 'price-drop' | 'availability' | 'threshold';\n  thresholdPercentage?: number;\n  status: 'active' | 'triggered' | 'expired' | 'cancelled';\n  createdAt: string;\n  lastChecked?: string;\n  priceHistory: Array<{\n    price: number;\n    currency: string;\n    timestamp: string;\n  }>;\n  userId?: string;\n  notificationMethod: 'email' | 'sms' | 'push';\n  notificationEmail?: string;\n  notificationPhone?: string;\n}\n\ninterface PriceSnapshot {\n  hotelId: string;\n  roomType: string;\n  price: number;\n  currency: string;\n  timestamp: string;\n  source: string;\n}\n\n// In-memory storage (in production, use database)\nconst priceAlerts = new Map<string, PriceAlert>();\nconst priceHistory = new Map<string, PriceSnapshot[]>();\n\n// ========================================\n// CREATE PRICE ALERT HANDLER\n// ========================================\n\ninterface CreateAlertParams {\n  hotelId: string;\n  hotelName: string;\n  roomType: string;\n  checkIn: string;\n  checkOut: string;\n  alertType: 'price-drop' | 'availability' | 'threshold';\n  targetPrice?: number;\n  thresholdPercentage?: number;\n  notificationMethod: 'email' | 'sms' | 'push';\n  email?: string;\n  phone?: string;\n}\n\nasync function handleCreatePriceAlert(\n  params: CreateAlertParams,\n  context: ConversationContext\n): Promise<ToolResult> {\n  try {\n    const alertId = `alert-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n\n    const alert: PriceAlert = {\n      id: alertId,\n      hotelId: params.hotelId,\n      hotelName: params.hotelName,\n      roomType: params.roomType,\n      checkIn: params.checkIn,\n      checkOut: params.checkOut,\n      alertType: params.alertType,\n      targetPrice: params.targetPrice,\n      thresholdPercentage: params.thresholdPercentage || 10,\n      status: 'active',\n      createdAt: new Date().toISOString(),\n      priceHistory: [],\n      userId: context.metadata.userId,\n      notificationMethod: params.notificationMethod,\n      notificationEmail: params.email,\n      notificationPhone: params.phone\n    };\n\n    priceAlerts.set(alertId, alert);\n\n    // Store alert ID in context\n    if (!context.metadata.priceAlerts) {\n      context.metadata.priceAlerts = [];\n    }\n    context.metadata.priceAlerts.push(alertId);\n\n    return {\n      success: true,\n      data: {\n        alertId,\n        hotelName: params.hotelName,\n        roomType: params.roomType,\n        dates: `${params.checkIn} to ${params.checkOut}`,\n        alertType: params.alertType,\n        targetPrice: params.targetPrice,\n        thresholdPercentage: params.thresholdPercentage,\n        notificationMethod: params.notificationMethod,\n        status: 'active',\n        message: 'Price alert created successfully. You will be notified when conditions are met.'\n      }\n    };\n  } catch (error: any) {\n    return {\n      success: false,\n      data: null,\n      error: error.message || 'Failed to create price alert'\n    };\n  }\n}\n\nregisterToolHandler('create_price_alert', handleCreatePriceAlert as any);\n\n// ========================================\n// GET PRICE ALERTS HANDLER\n// ========================================\n\ninterface GetAlertsParams {\n  status?: 'active' | 'triggered' | 'expired' | 'cancelled';\n  hotelId?: string;\n}\n\nasync function handleGetPriceAlerts(\n  params: GetAlertsParams,\n  context: ConversationContext\n): Promise<ToolResult> {\n  try {\n    let alerts = Array.from(priceAlerts.values());\n\n    // Filter by user if available\n    if (context.metadata.userId) {\n      alerts = alerts.filter(a => a.userId === context.metadata.userId);\n    }\n\n    // Filter by status\n    if (params.status) {\n      alerts = alerts.filter(a => a.status === params.status);\n    }\n\n    // Filter by hotel\n    if (params.hotelId) {\n      alerts = alerts.filter(a => a.hotelId === params.hotelId);\n    }\n\n    return {\n      success: true,\n      data: {\n        totalAlerts: alerts.length,\n        alerts: alerts.map(alert => ({\n          id: alert.id,\n          hotelName: alert.hotelName,\n          roomType: alert.roomType,\n          dates: `${alert.checkIn} to ${alert.checkOut}`,\n          alertType: alert.alertType,\n          targetPrice: alert.targetPrice,\n          status: alert.status,\n          createdAt: alert.createdAt,\n          lastChecked: alert.lastChecked,\n          currentPrice: alert.priceHistory[alert.priceHistory.length - 1]?.price,\n          priceChanges: alert.priceHistory.length\n        }))\n      }\n    };\n  } catch (error: any) {\n    return {\n      success: false,\n      data: null,\n      error: error.message || 'Failed to get price alerts'\n    };\n  }\n}\n\nregisterToolHandler('get_price_alerts', handleGetPriceAlerts);\n\n// ========================================\n// CANCEL PRICE ALERT HANDLER\n// ========================================\n\ninterface CancelAlertParams {\n  alertId: string;\n}\n\nasync function handleCancelPriceAlert(\n  params: CancelAlertParams,\n  context: ConversationContext\n): Promise<ToolResult> {\n  try {\n    const alert = priceAlerts.get(params.alertId);\n\n    if (!alert) {\n      return {\n        success: false,\n        data: null,\n        error: 'Price alert not found'\n      };\n    }\n\n    // Verify ownership\n    if (context.metadata.userId && alert.userId !== context.metadata.userId) {\n      return {\n        success: false,\n        data: null,\n        error: 'Not authorized to cancel this alert'\n      };\n    }\n\n    alert.status = 'cancelled';\n\n    return {\n      success: true,\n      data: {\n        alertId: params.alertId,\n        hotelName: alert.hotelName,\n        status: 'cancelled',\n        message: 'Price alert cancelled successfully'\n      }\n    };\n  } catch (error: any) {\n    return {\n      success: false,\n      data: null,\n      error: error.message || 'Failed to cancel price alert'\n    };\n  }\n}\n\nregisterToolHandler('cancel_price_alert', handleCancelPriceAlert as any);\n\n// ========================================\n// GET PRICE HISTORY HANDLER\n// ========================================\n\ninterface GetPriceHistoryParams {\n  hotelId: string;\n  roomType?: string;\n  startDate?: string;\n  endDate?: string;\n}\n\nasync function handleGetPriceHistory(\n  params: GetPriceHistoryParams,\n  context: ConversationContext\n): Promise<ToolResult> {\n  try {\n    const key = `${params.hotelId}-${params.roomType || 'all'}`;\n    const history = priceHistory.get(key) || [];\n\n    // Filter by date range if provided\n    let filteredHistory = history;\n    if (params.startDate || params.endDate) {\n      filteredHistory = history.filter(snapshot => {\n        const snapshotDate = new Date(snapshot.timestamp);\n        if (params.startDate && snapshotDate < new Date(params.startDate)) return false;\n        if (params.endDate && snapshotDate > new Date(params.endDate)) return false;\n        return true;\n      });\n    }\n\n    // Calculate statistics\n    const prices = filteredHistory.map(s => s.price);\n    const stats = prices.length > 0 ? {\n      minPrice: Math.min(...prices),\n      maxPrice: Math.max(...prices),\n      avgPrice: Math.round(prices.reduce((a, b) => a + b, 0) / prices.length),\n      currentPrice: prices[prices.length - 1],\n      priceChange: prices.length > 1\n        ? ((prices[prices.length - 1] - prices[0]) / prices[0] * 100).toFixed(1)\n        : 0\n    } : null;\n\n    return {\n      success: true,\n      data: {\n        hotelId: params.hotelId,\n        roomType: params.roomType,\n        dataPoints: filteredHistory.length,\n        dateRange: {\n          from: filteredHistory[0]?.timestamp,\n          to: filteredHistory[filteredHistory.length - 1]?.timestamp\n        },\n        statistics: stats,\n        trend: stats && Number(stats.priceChange) < -5 ? 'declining'\n          : stats && Number(stats.priceChange) > 5 ? 'rising'\n          : 'stable',\n        history: filteredHistory.slice(-30) // Last 30 data points\n      }\n    };\n  } catch (error: any) {\n    return {\n      success: false,\n      data: null,\n      error: error.message || 'Failed to get price history'\n    };\n  }\n}\n\nregisterToolHandler('get_price_history', handleGetPriceHistory as any);\n\n// ========================================\n// ANALYZE PRICE TRENDS HANDLER\n// ========================================\n\ninterface AnalyzeTrendsParams {\n  hotelId: string;\n  roomType?: string;\n  period?: 'week' | 'month' | 'quarter';\n}\n\nasync function handleAnalyzePriceTrends(\n  params: AnalyzeTrendsParams,\n  context: ConversationContext\n): Promise<ToolResult> {\n  try {\n    const key = `${params.hotelId}-${params.roomType || 'all'}`;\n    const history = priceHistory.get(key) || [];\n\n    // Determine period in days\n    const periodDays = params.period === 'week' ? 7\n      : params.period === 'quarter' ? 90\n      : 30;\n\n    const cutoffDate = new Date();\n    cutoffDate.setDate(cutoffDate.getDate() - periodDays);\n\n    const periodHistory = history.filter(\n      s => new Date(s.timestamp) >= cutoffDate\n    );\n\n    if (periodHistory.length < 2) {\n      return {\n        success: true,\n        data: {\n          hotelId: params.hotelId,\n          period: params.period || 'month',\n          message: 'Insufficient data for trend analysis',\n          recommendation: 'Continue monitoring to gather more price data'\n        }\n      };\n    }\n\n    const prices = periodHistory.map(s => s.price);\n    const startPrice = prices[0];\n    const endPrice = prices[prices.length - 1];\n    const changePercent = ((endPrice - startPrice) / startPrice * 100).toFixed(1);\n\n    // Calculate volatility\n    const avgPrice = prices.reduce((a, b) => a + b, 0) / prices.length;\n    const variance = prices.reduce((sum, p) => sum + Math.pow(p - avgPrice, 2), 0) / prices.length;\n    const volatility = Math.sqrt(variance);\n\n    // Determine trend\n    let trend: string;\n    let recommendation: string;\n\n    if (Number(changePercent) <= -10) {\n      trend = 'strong-decline';\n      recommendation = 'Great time to book! Prices have dropped significantly.';\n    } else if (Number(changePercent) <= -5) {\n      trend = 'moderate-decline';\n      recommendation = 'Good opportunity to book. Prices are trending down.';\n    } else if (Number(changePercent) >= 10) {\n      trend = 'strong-increase';\n      recommendation = 'Consider booking soon. Prices are rising quickly.';\n    } else if (Number(changePercent) >= 5) {\n      trend = 'moderate-increase';\n      recommendation = 'Prices are slowly rising. Book when ready.';\n    } else {\n      trend = 'stable';\n      recommendation = 'Prices are stable. No urgency to book.';\n    }\n\n    return {\n      success: true,\n      data: {\n        hotelId: params.hotelId,\n        roomType: params.roomType,\n        period: params.period || 'month',\n        dataPoints: periodHistory.length,\n        analysis: {\n          trend,\n          changePercent: `${changePercent}%`,\n          startPrice,\n          endPrice,\n          minPrice: Math.min(...prices),\n          maxPrice: Math.max(...prices),\n          avgPrice: Math.round(avgPrice),\n          volatility: volatility.toFixed(2),\n          volatilityLevel: volatility > avgPrice * 0.1 ? 'high'\n            : volatility > avgPrice * 0.05 ? 'moderate'\n            : 'low'\n        },\n        recommendation,\n        bestTimeToBook: trend.includes('decline')\n          ? 'Prices may drop further. Consider waiting a few more days.'\n          : trend.includes('increase')\n          ? 'Book now before prices increase more.'\n          : 'Current prices are reasonable. Book at your convenience.'\n      }\n    };\n  } catch (error: any) {\n    return {\n      success: false,\n      data: null,\n      error: error.message || 'Failed to analyze price trends'\n    };\n  }\n}\n\nregisterToolHandler('analyze_price_trends', handleAnalyzePriceTrends as any);\n\n// ========================================\n// COMPARE PRICES HANDLER\n// ========================================\n\ninterface ComparePricesParams {\n  hotelIds: string[];\n  checkIn: string;\n  checkOut: string;\n  roomType?: string;\n}\n\nasync function handleComparePrices(\n  params: ComparePricesParams,\n  context: ConversationContext\n): Promise<ToolResult> {\n  try {\n    // In production, this would fetch live prices from multiple sources\n    // For now, we simulate comparison data\n\n    const comparisons = params.hotelIds.map((hotelId, index) => {\n      const basePrice = 150 + Math.random() * 200;\n      return {\n        hotelId,\n        hotelName: `Hotel ${hotelId}`,\n        prices: [\n          { source: 'Direct', price: Math.round(basePrice), currency: 'USD' },\n          { source: 'Booking.com', price: Math.round(basePrice * 1.05), currency: 'USD' },\n          { source: 'Expedia', price: Math.round(basePrice * 1.08), currency: 'USD' },\n          { source: 'Hotels.com', price: Math.round(basePrice * 1.03), currency: 'USD' }\n        ],\n        bestPrice: Math.round(basePrice),\n        bestSource: 'Direct'\n      };\n    });\n\n    // Find overall best deal\n    const bestDeal = comparisons.reduce((best, current) =>\n      current.bestPrice < best.bestPrice ? current : best\n    );\n\n    return {\n      success: true,\n      data: {\n        checkIn: params.checkIn,\n        checkOut: params.checkOut,\n        roomType: params.roomType,\n        comparisons,\n        bestOverall: {\n          hotelId: bestDeal.hotelId,\n          hotelName: bestDeal.hotelName,\n          price: bestDeal.bestPrice,\n          source: bestDeal.bestSource\n        },\n        savings: `Book direct to save up to ${Math.round(Math.random() * 15 + 5)}%`\n      }\n    };\n  } catch (error: any) {\n    return {\n      success: false,\n      data: null,\n      error: error.message || 'Failed to compare prices'\n    };\n  }\n}\n\nregisterToolHandler('compare_prices', handleComparePrices as any);\n\n// ========================================\n// UTILITIES\n// ========================================\n\nexport function getAlert(alertId: string): PriceAlert | undefined {\n  return priceAlerts.get(alertId);\n}\n\nexport function getActiveAlerts(): PriceAlert[] {\n  return Array.from(priceAlerts.values()).filter(a => a.status === 'active');\n}\n\nexport function addPriceSnapshot(snapshot: PriceSnapshot): void {\n  const key = `${snapshot.hotelId}-${snapshot.roomType}`;\n  const history = priceHistory.get(key) || [];\n  history.push(snapshot);\n  priceHistory.set(key, history);\n\n  // Check for alerts\n  checkPriceAlerts(snapshot);\n}\n\nfunction checkPriceAlerts(snapshot: PriceSnapshot): void {\n  const alerts = getActiveAlerts();\n\n  for (const alert of alerts) {\n    if (alert.hotelId !== snapshot.hotelId) continue;\n    if (alert.roomType && alert.roomType !== snapshot.roomType) continue;\n\n    // Add to alert history\n    alert.priceHistory.push({\n      price: snapshot.price,\n      currency: snapshot.currency,\n      timestamp: snapshot.timestamp\n    });\n    alert.lastChecked = snapshot.timestamp;\n\n    // Check trigger conditions\n    if (alert.alertType === 'threshold' && alert.targetPrice) {\n      if (snapshot.price <= alert.targetPrice) {\n        triggerAlert(alert, snapshot);\n      }\n    } else if (alert.alertType === 'price-drop' && alert.priceHistory.length > 1) {\n      const previousPrice = alert.priceHistory[alert.priceHistory.length - 2].price;\n      const dropPercent = ((previousPrice - snapshot.price) / previousPrice) * 100;\n      if (dropPercent >= (alert.thresholdPercentage || 10)) {\n        triggerAlert(alert, snapshot);\n      }\n    }\n  }\n}\n\nfunction triggerAlert(alert: PriceAlert, snapshot: PriceSnapshot): void {\n  alert.status = 'triggered';\n  console.log(`Alert triggered: ${alert.id} for ${alert.hotelName} at ${snapshot.price} ${snapshot.currency}`);\n  // In production, send notification via email/SMS/push\n}\n\nexport {\n  handleCreatePriceAlert,\n  handleGetPriceAlerts,\n  handleCancelPriceAlert,\n  handleGetPriceHistory,\n  handleAnalyzePriceTrends,\n  handleComparePrices\n};\n","/**\n * Hotel Booking AI - Notifications Handler\n * Handles email, SMS, and push notifications\n */\n\nimport type { ConversationContext, ToolResult } from '../types';\nimport { registerToolHandler } from '../engine-manager';\n\n// ========================================\n// EMAIL NOTIFICATION HANDLER\n// ========================================\n\ninterface SendEmailParams {\n  to: string;\n  subject: string;\n  body: string;\n  templateId?: string;\n  templateData?: Record<string, any>;\n  replyTo?: string;\n  cc?: string[];\n  attachments?: Array<{\n    filename: string;\n    content: string;\n    contentType: string;\n  }>;\n}\n\nasync function handleSendEmail(\n  params: SendEmailParams,\n  context: ConversationContext\n): Promise<ToolResult> {\n  try {\n    // Validate email format\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    if (!emailRegex.test(params.to)) {\n      return {\n        success: false,\n        data: null,\n        error: 'Invalid email address format'\n      };\n    }\n\n    const messageId = `email-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n\n    // In production, this would use Resend/SendGrid/etc.\n    // For now, we log and simulate\n    console.log(`Sending email to ${params.to}: ${params.subject}`);\n\n    // Track sent emails in context\n    if (!context.metadata.sentNotifications) {\n      context.metadata.sentNotifications = [];\n    }\n    context.metadata.sentNotifications.push({\n      id: messageId,\n      type: 'email',\n      to: params.to,\n      subject: params.subject,\n      sentAt: new Date().toISOString()\n    });\n\n    return {\n      success: true,\n      data: {\n        messageId,\n        to: params.to,\n        subject: params.subject,\n        status: 'sent',\n        timestamp: new Date().toISOString(),\n        message: 'Email sent successfully'\n      }\n    };\n  } catch (error: any) {\n    return {\n      success: false,\n      data: null,\n      error: error.message || 'Failed to send email'\n    };\n  }\n}\n\nregisterToolHandler('send_email', handleSendEmail as any);\n\n// ========================================\n// BOOKING CONFIRMATION EMAIL\n// ========================================\n\ninterface SendBookingConfirmationParams {\n  email: string;\n  bookingDetails: {\n    confirmationNumber: string;\n    guestName: string;\n    hotelName: string;\n    hotelAddress: string;\n    checkIn: string;\n    checkOut: string;\n    roomType: string;\n    totalPrice: number;\n    currency: string;\n    cancellationPolicy?: string;\n  };\n  language?: 'en' | 'he';\n}\n\nasync function handleSendBookingConfirmation(\n  params: SendBookingConfirmationParams,\n  context: ConversationContext\n): Promise<ToolResult> {\n  try {\n    const { bookingDetails, language = 'en' } = params;\n\n    const subject = language === 'he'\n      ? `אישור הזמנה - ${bookingDetails.hotelName}`\n      : `Booking Confirmation - ${bookingDetails.hotelName}`;\n\n    const body = language === 'he' ? `\nשלום ${bookingDetails.guestName},\n\nתודה על הזמנתך! להלן פרטי ההזמנה:\n\nמספר אישור: ${bookingDetails.confirmationNumber}\nמלון: ${bookingDetails.hotelName}\nכתובת: ${bookingDetails.hotelAddress}\nצ'ק-אין: ${bookingDetails.checkIn}\nצ'ק-אאוט: ${bookingDetails.checkOut}\nסוג חדר: ${bookingDetails.roomType}\nסה\"כ: ${bookingDetails.currency} ${bookingDetails.totalPrice}\n\n${bookingDetails.cancellationPolicy ? `מדיניות ביטול: ${bookingDetails.cancellationPolicy}` : ''}\n\nנתראה!\n    ` : `\nDear ${bookingDetails.guestName},\n\nThank you for your booking! Here are your reservation details:\n\nConfirmation Number: ${bookingDetails.confirmationNumber}\nHotel: ${bookingDetails.hotelName}\nAddress: ${bookingDetails.hotelAddress}\nCheck-in: ${bookingDetails.checkIn}\nCheck-out: ${bookingDetails.checkOut}\nRoom Type: ${bookingDetails.roomType}\nTotal: ${bookingDetails.currency} ${bookingDetails.totalPrice}\n\n${bookingDetails.cancellationPolicy ? `Cancellation Policy: ${bookingDetails.cancellationPolicy}` : ''}\n\nWe look forward to welcoming you!\n    `;\n\n    return handleSendEmail({\n      to: params.email,\n      subject,\n      body,\n      templateId: 'booking-confirmation',\n      templateData: bookingDetails\n    }, context);\n  } catch (error: any) {\n    return {\n      success: false,\n      data: null,\n      error: error.message || 'Failed to send booking confirmation'\n    };\n  }\n}\n\nregisterToolHandler('send_booking_confirmation', handleSendBookingConfirmation as any);\n\n// ========================================\n// CANCELLATION CONFIRMATION EMAIL\n// ========================================\n\ninterface SendCancellationConfirmationParams {\n  email: string;\n  cancellationDetails: {\n    confirmationNumber: string;\n    cancellationId: string;\n    guestName: string;\n    hotelName: string;\n    refundAmount?: number;\n    refundCurrency?: string;\n    refundStatus?: string;\n  };\n  language?: 'en' | 'he';\n}\n\nasync function handleSendCancellationConfirmation(\n  params: SendCancellationConfirmationParams,\n  context: ConversationContext\n): Promise<ToolResult> {\n  try {\n    const { cancellationDetails, language = 'en' } = params;\n\n    const subject = language === 'he'\n      ? `אישור ביטול - ${cancellationDetails.hotelName}`\n      : `Cancellation Confirmation - ${cancellationDetails.hotelName}`;\n\n    const refundInfo = cancellationDetails.refundAmount\n      ? language === 'he'\n        ? `סכום החזר: ${cancellationDetails.refundCurrency} ${cancellationDetails.refundAmount}`\n        : `Refund Amount: ${cancellationDetails.refundCurrency} ${cancellationDetails.refundAmount}`\n      : '';\n\n    const body = language === 'he' ? `\nשלום ${cancellationDetails.guestName},\n\nהזמנתך בוטלה בהצלחה.\n\nמספר הזמנה מקורי: ${cancellationDetails.confirmationNumber}\nמספר ביטול: ${cancellationDetails.cancellationId}\nמלון: ${cancellationDetails.hotelName}\n${refundInfo}\n\nנשמח לשרת אותך בעתיד.\n    ` : `\nDear ${cancellationDetails.guestName},\n\nYour booking has been successfully cancelled.\n\nOriginal Confirmation: ${cancellationDetails.confirmationNumber}\nCancellation ID: ${cancellationDetails.cancellationId}\nHotel: ${cancellationDetails.hotelName}\n${refundInfo}\n\nWe hope to serve you again in the future.\n    `;\n\n    return handleSendEmail({\n      to: params.email,\n      subject,\n      body,\n      templateId: 'cancellation-confirmation',\n      templateData: cancellationDetails\n    }, context);\n  } catch (error: any) {\n    return {\n      success: false,\n      data: null,\n      error: error.message || 'Failed to send cancellation confirmation'\n    };\n  }\n}\n\nregisterToolHandler('send_cancellation_confirmation', handleSendCancellationConfirmation as any);\n\n// ========================================\n// PRICE ALERT NOTIFICATION\n// ========================================\n\ninterface SendPriceAlertParams {\n  email?: string;\n  phone?: string;\n  alertDetails: {\n    hotelName: string;\n    roomType: string;\n    dates: string;\n    previousPrice: number;\n    currentPrice: number;\n    currency: string;\n    priceChange: number;\n    bookingUrl?: string;\n  };\n  method: 'email' | 'sms' | 'push';\n  language?: 'en' | 'he';\n}\n\nasync function handleSendPriceAlert(\n  params: SendPriceAlertParams,\n  context: ConversationContext\n): Promise<ToolResult> {\n  try {\n    const { alertDetails, method, language = 'en' } = params;\n\n    if (method === 'email' && !params.email) {\n      return {\n        success: false,\n        data: null,\n        error: 'Email address required for email notifications'\n      };\n    }\n\n    if (method === 'sms' && !params.phone) {\n      return {\n        success: false,\n        data: null,\n        error: 'Phone number required for SMS notifications'\n      };\n    }\n\n    const changeText = alertDetails.priceChange < 0\n      ? (language === 'he' ? 'ירידה' : 'dropped')\n      : (language === 'he' ? 'עלייה' : 'increased');\n\n    const messageId = `alert-${Date.now()}-${Math.random().toString(36).substr(2, 6)}`;\n\n    if (method === 'email') {\n      const subject = language === 'he'\n        ? `🔔 התראת מחיר: ${alertDetails.hotelName}`\n        : `🔔 Price Alert: ${alertDetails.hotelName}`;\n\n      const body = language === 'he' ? `\nהמחיר עבור ${alertDetails.hotelName} ${changeText}!\n\nחדר: ${alertDetails.roomType}\nתאריכים: ${alertDetails.dates}\nמחיר קודם: ${alertDetails.currency} ${alertDetails.previousPrice}\nמחיר נוכחי: ${alertDetails.currency} ${alertDetails.currentPrice}\nשינוי: ${alertDetails.priceChange}%\n\n${alertDetails.bookingUrl ? `להזמנה: ${alertDetails.bookingUrl}` : ''}\n      ` : `\nThe price for ${alertDetails.hotelName} has ${changeText}!\n\nRoom: ${alertDetails.roomType}\nDates: ${alertDetails.dates}\nPrevious Price: ${alertDetails.currency} ${alertDetails.previousPrice}\nCurrent Price: ${alertDetails.currency} ${alertDetails.currentPrice}\nChange: ${alertDetails.priceChange}%\n\n${alertDetails.bookingUrl ? `Book now: ${alertDetails.bookingUrl}` : ''}\n      `;\n\n      return handleSendEmail({\n        to: params.email!,\n        subject,\n        body,\n        templateId: 'price-alert'\n      }, context);\n    } else if (method === 'sms') {\n      // SMS handler would be called here\n      const smsMessage = language === 'he'\n        ? `🔔 ${alertDetails.hotelName}: המחיר ${changeText} ל-${alertDetails.currency}${alertDetails.currentPrice} (${alertDetails.priceChange}%)`\n        : `🔔 ${alertDetails.hotelName}: Price ${changeText} to ${alertDetails.currency}${alertDetails.currentPrice} (${alertDetails.priceChange}%)`;\n\n      // Track notification\n      if (!context.metadata.sentNotifications) {\n        context.metadata.sentNotifications = [];\n      }\n      context.metadata.sentNotifications.push({\n        id: messageId,\n        type: 'sms',\n        to: params.phone,\n        content: smsMessage,\n        sentAt: new Date().toISOString()\n      });\n\n      return {\n        success: true,\n        data: {\n          messageId,\n          to: params.phone,\n          type: 'sms',\n          status: 'sent',\n          message: 'Price alert SMS sent successfully'\n        }\n      };\n    } else {\n      // Push notification\n      return {\n        success: true,\n        data: {\n          messageId,\n          type: 'push',\n          status: 'sent',\n          message: 'Push notification sent successfully'\n        }\n      };\n    }\n  } catch (error: any) {\n    return {\n      success: false,\n      data: null,\n      error: error.message || 'Failed to send price alert notification'\n    };\n  }\n}\n\nregisterToolHandler('send_price_alert', handleSendPriceAlert as any);\n\n// ========================================\n// REMINDER NOTIFICATION\n// ========================================\n\ninterface SendReminderParams {\n  email?: string;\n  phone?: string;\n  reminderDetails: {\n    type: 'check-in' | 'check-out' | 'payment' | 'review' | 'custom';\n    title: string;\n    message: string;\n    hotelName?: string;\n    date?: string;\n    actionUrl?: string;\n  };\n  method: 'email' | 'sms' | 'push';\n}\n\nasync function handleSendReminder(\n  params: SendReminderParams,\n  context: ConversationContext\n): Promise<ToolResult> {\n  try {\n    const { reminderDetails, method } = params;\n\n    const messageId = `reminder-${Date.now()}-${Math.random().toString(36).substr(2, 6)}`;\n\n    if (method === 'email' && params.email) {\n      return handleSendEmail({\n        to: params.email,\n        subject: reminderDetails.title,\n        body: reminderDetails.message,\n        templateId: `reminder-${reminderDetails.type}`\n      }, context);\n    }\n\n    // Track reminder\n    if (!context.metadata.sentNotifications) {\n      context.metadata.sentNotifications = [];\n    }\n    context.metadata.sentNotifications.push({\n      id: messageId,\n      type: method,\n      reminderType: reminderDetails.type,\n      title: reminderDetails.title,\n      sentAt: new Date().toISOString()\n    });\n\n    return {\n      success: true,\n      data: {\n        messageId,\n        type: method,\n        reminderType: reminderDetails.type,\n        status: 'sent',\n        message: 'Reminder sent successfully'\n      }\n    };\n  } catch (error: any) {\n    return {\n      success: false,\n      data: null,\n      error: error.message || 'Failed to send reminder'\n    };\n  }\n}\n\nregisterToolHandler('send_reminder', handleSendReminder as any);\n\n// ========================================\n// GET NOTIFICATION HISTORY\n// ========================================\n\ninterface GetNotificationHistoryParams {\n  limit?: number;\n  type?: 'email' | 'sms' | 'push';\n}\n\nasync function handleGetNotificationHistory(\n  params: GetNotificationHistoryParams,\n  context: ConversationContext\n): Promise<ToolResult> {\n  try {\n    let notifications = context.metadata.sentNotifications || [];\n\n    if (params.type) {\n      notifications = notifications.filter((n: any) => n.type === params.type);\n    }\n\n    if (params.limit) {\n      notifications = notifications.slice(-params.limit);\n    }\n\n    return {\n      success: true,\n      data: {\n        totalNotifications: notifications.length,\n        notifications: notifications.map((n: any) => ({\n          id: n.id,\n          type: n.type,\n          to: n.to,\n          subject: n.subject,\n          sentAt: n.sentAt\n        }))\n      }\n    };\n  } catch (error: any) {\n    return {\n      success: false,\n      data: null,\n      error: error.message || 'Failed to get notification history'\n    };\n  }\n}\n\nregisterToolHandler('get_notification_history', handleGetNotificationHistory);\n\nexport {\n  handleSendEmail,\n  handleSendBookingConfirmation,\n  handleSendCancellationConfirmation,\n  handleSendPriceAlert,\n  handleSendReminder,\n  handleGetNotificationHistory\n};\n","/**\n * Hotel Booking AI - Loyalty Handler\n * Handles loyalty program, points, and member benefits\n */\n\nimport type { ConversationContext, ToolResult } from '../types';\nimport { registerToolHandler } from '../engine-manager';\n\n// ========================================\n// LOYALTY DATA STRUCTURES\n// ========================================\n\ninterface LoyaltyMember {\n  id: string;\n  email: string;\n  firstName: string;\n  lastName: string;\n  tier: 'bronze' | 'silver' | 'gold' | 'platinum';\n  points: number;\n  lifetimePoints: number;\n  tierProgressPoints: number;\n  nextTierThreshold: number;\n  joinDate: string;\n  expiringPoints?: {\n    amount: number;\n    expiryDate: string;\n  };\n  preferences: Record<string, any>;\n}\n\ninterface LoyaltyTransaction {\n  id: string;\n  memberId: string;\n  type: 'earn' | 'redeem' | 'expire' | 'bonus' | 'adjustment';\n  points: number;\n  description: string;\n  bookingId?: string;\n  timestamp: string;\n}\n\n// In-memory storage (in production, use database)\nconst loyaltyMembers = new Map<string, LoyaltyMember>();\nconst loyaltyTransactions: LoyaltyTransaction[] = [];\n\n// Tier thresholds\nconst TIER_THRESHOLDS = {\n  bronze: 0,\n  silver: 5000,\n  gold: 15000,\n  platinum: 50000\n};\n\nconst TIER_BENEFITS = {\n  bronze: ['Earn 1 point per $1', 'Member-only rates', 'Birthday bonus'],\n  silver: ['Earn 1.25 points per $1', 'Late checkout', 'Welcome drink', 'Priority support'],\n  gold: ['Earn 1.5 points per $1', 'Room upgrade when available', 'Lounge access', 'Free breakfast'],\n  platinum: ['Earn 2 points per $1', 'Guaranteed upgrade', 'Suite access', 'Personal concierge', 'Airport transfer']\n};\n\n// ========================================\n// GET LOYALTY ACCOUNT HANDLER\n// ========================================\n\ninterface GetLoyaltyAccountParams {\n  memberId?: string;\n  email?: string;\n}\n\nasync function handleGetLoyaltyAccount(\n  params: GetLoyaltyAccountParams,\n  context: ConversationContext\n): Promise<ToolResult> {\n  try {\n    let member: LoyaltyMember | undefined;\n\n    if (params.memberId) {\n      member = loyaltyMembers.get(params.memberId);\n    } else if (params.email) {\n      member = Array.from(loyaltyMembers.values()).find(m => m.email === params.email);\n    } else if (context.metadata.loyaltyMemberId) {\n      member = loyaltyMembers.get(context.metadata.loyaltyMemberId);\n    }\n\n    if (!member) {\n      return {\n        success: false,\n        data: null,\n        error: 'Loyalty member not found'\n      };\n    }\n\n    const tierBenefits = TIER_BENEFITS[member.tier];\n    const nextTier = member.tier === 'platinum' ? null\n      : member.tier === 'gold' ? 'platinum'\n      : member.tier === 'silver' ? 'gold'\n      : 'silver';\n\n    const pointsToNextTier = nextTier\n      ? TIER_THRESHOLDS[nextTier] - member.tierProgressPoints\n      : 0;\n\n    return {\n      success: true,\n      data: {\n        memberId: member.id,\n        name: `${member.firstName} ${member.lastName}`,\n        email: member.email,\n        tier: member.tier,\n        points: member.points,\n        lifetimePoints: member.lifetimePoints,\n        tierProgress: {\n          currentPoints: member.tierProgressPoints,\n          nextTier,\n          pointsToNextTier,\n          progressPercent: nextTier\n            ? Math.round((member.tierProgressPoints / TIER_THRESHOLDS[nextTier]) * 100)\n            : 100\n        },\n        benefits: tierBenefits,\n        expiringPoints: member.expiringPoints,\n        memberSince: member.joinDate\n      }\n    };\n  } catch (error: any) {\n    return {\n      success: false,\n      data: null,\n      error: error.message || 'Failed to get loyalty account'\n    };\n  }\n}\n\nregisterToolHandler('get_loyalty_account', handleGetLoyaltyAccount);\n\n// ========================================\n// GET POINTS BALANCE HANDLER\n// ========================================\n\ninterface GetPointsBalanceParams {\n  memberId?: string;\n}\n\nasync function handleGetPointsBalance(\n  params: GetPointsBalanceParams,\n  context: ConversationContext\n): Promise<ToolResult> {\n  try {\n    const memberId = params.memberId || context.metadata.loyaltyMemberId;\n\n    if (!memberId) {\n      return {\n        success: false,\n        data: null,\n        error: 'Member ID required'\n      };\n    }\n\n    const member = loyaltyMembers.get(memberId);\n    if (!member) {\n      return {\n        success: false,\n        data: null,\n        error: 'Loyalty member not found'\n      };\n    }\n\n    // Get recent transactions\n    const recentTransactions = loyaltyTransactions\n      .filter(t => t.memberId === memberId)\n      .slice(-5)\n      .map(t => ({\n        type: t.type,\n        points: t.points,\n        description: t.description,\n        date: t.timestamp\n      }));\n\n    return {\n      success: true,\n      data: {\n        memberId: member.id,\n        availablePoints: member.points,\n        lifetimePoints: member.lifetimePoints,\n        tier: member.tier,\n        expiringPoints: member.expiringPoints,\n        recentTransactions\n      }\n    };\n  } catch (error: any) {\n    return {\n      success: false,\n      data: null,\n      error: error.message || 'Failed to get points balance'\n    };\n  }\n}\n\nregisterToolHandler('get_points_balance', handleGetPointsBalance);\n\n// ========================================\n// EARN POINTS HANDLER\n// ========================================\n\ninterface EarnPointsParams {\n  memberId?: string;\n  email?: string;\n  amount: number;\n  bookingId?: string;\n  description?: string;\n  bonusMultiplier?: number;\n}\n\nasync function handleEarnPoints(\n  params: EarnPointsParams,\n  context: ConversationContext\n): Promise<ToolResult> {\n  try {\n    let member: LoyaltyMember | undefined;\n\n    if (params.memberId) {\n      member = loyaltyMembers.get(params.memberId);\n    } else if (params.email) {\n      member = Array.from(loyaltyMembers.values()).find(m => m.email === params.email);\n    }\n\n    if (!member) {\n      return {\n        success: false,\n        data: null,\n        error: 'Loyalty member not found'\n      };\n    }\n\n    // Calculate points based on tier\n    const tierMultipliers = {\n      bronze: 1,\n      silver: 1.25,\n      gold: 1.5,\n      platinum: 2\n    };\n\n    const basePoints = Math.round(params.amount);\n    const tierMultiplier = tierMultipliers[member.tier];\n    const bonusMultiplier = params.bonusMultiplier || 1;\n    const earnedPoints = Math.round(basePoints * tierMultiplier * bonusMultiplier);\n\n    // Update member points\n    member.points += earnedPoints;\n    member.lifetimePoints += earnedPoints;\n    member.tierProgressPoints += earnedPoints;\n\n    // Check for tier upgrade\n    let tierUpgrade: string | null = null;\n    if (member.tier === 'bronze' && member.tierProgressPoints >= TIER_THRESHOLDS.silver) {\n      member.tier = 'silver';\n      tierUpgrade = 'silver';\n    } else if (member.tier === 'silver' && member.tierProgressPoints >= TIER_THRESHOLDS.gold) {\n      member.tier = 'gold';\n      tierUpgrade = 'gold';\n    } else if (member.tier === 'gold' && member.tierProgressPoints >= TIER_THRESHOLDS.platinum) {\n      member.tier = 'platinum';\n      tierUpgrade = 'platinum';\n    }\n\n    // Record transaction\n    const transaction: LoyaltyTransaction = {\n      id: `txn-${Date.now()}-${Math.random().toString(36).substr(2, 6)}`,\n      memberId: member.id,\n      type: 'earn',\n      points: earnedPoints,\n      description: params.description || `Earned from booking ${params.bookingId || 'N/A'}`,\n      bookingId: params.bookingId,\n      timestamp: new Date().toISOString()\n    };\n    loyaltyTransactions.push(transaction);\n\n    return {\n      success: true,\n      data: {\n        memberId: member.id,\n        pointsEarned: earnedPoints,\n        breakdown: {\n          basePoints,\n          tierMultiplier,\n          bonusMultiplier,\n          total: earnedPoints\n        },\n        newBalance: member.points,\n        tierUpgrade,\n        tier: member.tier,\n        transactionId: transaction.id,\n        message: tierUpgrade\n          ? `Congratulations! You earned ${earnedPoints} points and upgraded to ${tierUpgrade}!`\n          : `You earned ${earnedPoints} points!`\n      }\n    };\n  } catch (error: any) {\n    return {\n      success: false,\n      data: null,\n      error: error.message || 'Failed to earn points'\n    };\n  }\n}\n\nregisterToolHandler('earn_points', handleEarnPoints as any);\n\n// ========================================\n// REDEEM POINTS HANDLER\n// ========================================\n\ninterface RedeemPointsParams {\n  memberId?: string;\n  points: number;\n  rewardType: 'discount' | 'free-night' | 'upgrade' | 'experience' | 'transfer';\n  rewardDetails?: Record<string, any>;\n}\n\nasync function handleRedeemPoints(\n  params: RedeemPointsParams,\n  context: ConversationContext\n): Promise<ToolResult> {\n  try {\n    const memberId = params.memberId || context.metadata.loyaltyMemberId;\n\n    if (!memberId) {\n      return {\n        success: false,\n        data: null,\n        error: 'Member ID required'\n      };\n    }\n\n    const member = loyaltyMembers.get(memberId);\n    if (!member) {\n      return {\n        success: false,\n        data: null,\n        error: 'Loyalty member not found'\n      };\n    }\n\n    if (member.points < params.points) {\n      return {\n        success: false,\n        data: null,\n        error: `Insufficient points. You have ${member.points} points, need ${params.points}`\n      };\n    }\n\n    // Deduct points\n    member.points -= params.points;\n\n    // Record transaction\n    const transaction: LoyaltyTransaction = {\n      id: `txn-${Date.now()}-${Math.random().toString(36).substr(2, 6)}`,\n      memberId: member.id,\n      type: 'redeem',\n      points: -params.points,\n      description: `Redeemed for ${params.rewardType}`,\n      timestamp: new Date().toISOString()\n    };\n    loyaltyTransactions.push(transaction);\n\n    // Calculate reward value\n    const rewardValues = {\n      discount: params.points * 0.01, // 1 cent per point\n      'free-night': params.points >= 10000 ? 1 : 0,\n      upgrade: params.points >= 5000 ? 'room-upgrade' : null,\n      experience: 'experience-voucher',\n      transfer: params.points\n    };\n\n    return {\n      success: true,\n      data: {\n        memberId: member.id,\n        pointsRedeemed: params.points,\n        rewardType: params.rewardType,\n        rewardValue: rewardValues[params.rewardType],\n        remainingPoints: member.points,\n        transactionId: transaction.id,\n        redemptionCode: `RDM-${Date.now().toString(36).toUpperCase()}`,\n        message: `Successfully redeemed ${params.points} points for ${params.rewardType}`\n      }\n    };\n  } catch (error: any) {\n    return {\n      success: false,\n      data: null,\n      error: error.message || 'Failed to redeem points'\n    };\n  }\n}\n\nregisterToolHandler('redeem_points', handleRedeemPoints as any);\n\n// ========================================\n// GET TIER BENEFITS HANDLER\n// ========================================\n\ninterface GetTierBenefitsParams {\n  tier?: 'bronze' | 'silver' | 'gold' | 'platinum';\n  memberId?: string;\n}\n\nasync function handleGetTierBenefits(\n  params: GetTierBenefitsParams,\n  context: ConversationContext\n): Promise<ToolResult> {\n  try {\n    let tier = params.tier;\n\n    if (!tier && params.memberId) {\n      const member = loyaltyMembers.get(params.memberId);\n      if (member) tier = member.tier;\n    }\n\n    if (!tier && context.metadata.loyaltyMemberId) {\n      const member = loyaltyMembers.get(context.metadata.loyaltyMemberId);\n      if (member) tier = member.tier;\n    }\n\n    if (!tier) tier = 'bronze';\n\n    const allTiers = ['bronze', 'silver', 'gold', 'platinum'] as const;\n    const tierIndex = allTiers.indexOf(tier);\n\n    return {\n      success: true,\n      data: {\n        currentTier: tier,\n        benefits: TIER_BENEFITS[tier],\n        threshold: TIER_THRESHOLDS[tier],\n        nextTier: tierIndex < 3 ? allTiers[tierIndex + 1] : null,\n        nextTierThreshold: tierIndex < 3 ? TIER_THRESHOLDS[allTiers[tierIndex + 1]] : null,\n        allTiers: allTiers.map(t => ({\n          name: t,\n          threshold: TIER_THRESHOLDS[t],\n          benefits: TIER_BENEFITS[t]\n        }))\n      }\n    };\n  } catch (error: any) {\n    return {\n      success: false,\n      data: null,\n      error: error.message || 'Failed to get tier benefits'\n    };\n  }\n}\n\nregisterToolHandler('get_tier_benefits', handleGetTierBenefits);\n\n// ========================================\n// GET TRANSACTION HISTORY HANDLER\n// ========================================\n\ninterface GetTransactionHistoryParams {\n  memberId?: string;\n  type?: 'earn' | 'redeem' | 'expire' | 'bonus' | 'adjustment';\n  limit?: number;\n}\n\nasync function handleGetTransactionHistory(\n  params: GetTransactionHistoryParams,\n  context: ConversationContext\n): Promise<ToolResult> {\n  try {\n    const memberId = params.memberId || context.metadata.loyaltyMemberId;\n\n    if (!memberId) {\n      return {\n        success: false,\n        data: null,\n        error: 'Member ID required'\n      };\n    }\n\n    let transactions = loyaltyTransactions.filter(t => t.memberId === memberId);\n\n    if (params.type) {\n      transactions = transactions.filter(t => t.type === params.type);\n    }\n\n    if (params.limit) {\n      transactions = transactions.slice(-params.limit);\n    }\n\n    const totalEarned = transactions\n      .filter(t => t.type === 'earn' || t.type === 'bonus')\n      .reduce((sum, t) => sum + t.points, 0);\n\n    const totalRedeemed = transactions\n      .filter(t => t.type === 'redeem')\n      .reduce((sum, t) => sum + Math.abs(t.points), 0);\n\n    return {\n      success: true,\n      data: {\n        memberId,\n        totalTransactions: transactions.length,\n        summary: {\n          totalEarned,\n          totalRedeemed,\n          netPoints: totalEarned - totalRedeemed\n        },\n        transactions: transactions.map(t => ({\n          id: t.id,\n          type: t.type,\n          points: t.points,\n          description: t.description,\n          bookingId: t.bookingId,\n          date: t.timestamp\n        }))\n      }\n    };\n  } catch (error: any) {\n    return {\n      success: false,\n      data: null,\n      error: error.message || 'Failed to get transaction history'\n    };\n  }\n}\n\nregisterToolHandler('get_transaction_history', handleGetTransactionHistory);\n\n// ========================================\n// UTILITIES\n// ========================================\n\nexport function createMember(data: {\n  email: string;\n  firstName: string;\n  lastName: string;\n}): LoyaltyMember {\n  const member: LoyaltyMember = {\n    id: `member-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n    email: data.email,\n    firstName: data.firstName,\n    lastName: data.lastName,\n    tier: 'bronze',\n    points: 0,\n    lifetimePoints: 0,\n    tierProgressPoints: 0,\n    nextTierThreshold: TIER_THRESHOLDS.silver,\n    joinDate: new Date().toISOString(),\n    preferences: {}\n  };\n\n  loyaltyMembers.set(member.id, member);\n  return member;\n}\n\nexport function getMember(memberId: string): LoyaltyMember | undefined {\n  return loyaltyMembers.get(memberId);\n}\n\nexport function getMemberByEmail(email: string): LoyaltyMember | undefined {\n  return Array.from(loyaltyMembers.values()).find(m => m.email === email);\n}\n\nexport {\n  handleGetLoyaltyAccount,\n  handleGetPointsBalance,\n  handleEarnPoints,\n  handleRedeemPoints,\n  handleGetTierBenefits,\n  handleGetTransactionHistory\n};\n"],"names":[],"mappings":"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"}